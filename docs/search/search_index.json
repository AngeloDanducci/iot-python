{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python for IBM Watson IoT Platform \uf0c1 Python module for interacting with the IBM Watson IoT Platform . Python 3.7 Python 2.7 Note: Support for MQTT with TLS requires at least Python v2.7.9 or v3.4, and openssl v1.0.1 Documentation for this SDK can be broken down into 4 distinct areas: Application Development Device Development Gateway Development Common Topics Custom Message Formats Exceptions Additional documentation for the library is available in IBM Cloud, but it's a \"little\" out of date in places: Application Developers Device Developers Dependencies \uf0c1 paho-mqtt iso8601 pytz requests Installation \uf0c1 Install the latest version of the library with pip # pip install wiotp-sdk Uninstall \uf0c1 Uninstalling the module is simple. # pip uninstall wiotp-sdk","title":"Home"},{"location":"#python-for-ibm-watson-iot-platform","text":"Python module for interacting with the IBM Watson IoT Platform . Python 3.7 Python 2.7 Note: Support for MQTT with TLS requires at least Python v2.7.9 or v3.4, and openssl v1.0.1 Documentation for this SDK can be broken down into 4 distinct areas: Application Development Device Development Gateway Development Common Topics Custom Message Formats Exceptions Additional documentation for the library is available in IBM Cloud, but it's a \"little\" out of date in places: Application Developers Device Developers","title":"Python for IBM Watson IoT Platform"},{"location":"#dependencies","text":"paho-mqtt iso8601 pytz requests","title":"Dependencies"},{"location":"#installation","text":"Install the latest version of the library with pip # pip install wiotp-sdk","title":"Installation"},{"location":"#uninstall","text":"Uninstalling the module is simple. # pip uninstall wiotp-sdk","title":"Uninstall"},{"location":"custommsg/","text":"Custom Message Formats \uf0c1 By default, the client library support encoding and decoding events and commands as json messages. To add support for your own custom message formats you can create and register implementations of wiotp.sdk.MessageCodec . MessageCodecs work for both commands and events. To Implement a MessageCodec you must support two static class methods: Encoding \uf0c1 The job of the encode(data, timestamp) method is to take data (any python object) and optionally a timestamp (a datetime.datetime object) and return a String representation of the message ready to be sent over MQTT. Decoding \uf0c1 The job of decode(message) is to decode an incoming MQTT message and return an instance of ibmiotf.Message Sample Code \uf0c1 import yaml import wiotp.sdk.device import wiotp.sdk.Message import wiotp.sdk.MessageCodec class YamlCodec(ibmiotf.MessageCodec): @staticmethod def encode(data=None, timestamp=None): return yaml.dumps(data) @staticmethod def decode(message): try: data = yaml.loads(message.payload.decode( utf-8 )) except ValueError as e: raise InvalidEventException( Unable to parse YAML. payload=\\ %s\\ error=%s % (message.payload, str(e))) timestamp = datetime.now(pytz.timezone('UTC')) return wiotp.sdk.Message(data, timestamp) myConfig = ibmiotf.device.ParseConfigFile( device.yaml ) client = ibmiotf.device.Client(config=myConfig, logHandlers=None) client.setMessageCodec( yaml , YamlCodec) myData = { 'hello' : 'world', 'x' : 100} # Publish the same event, in both json and yaml formats: client.publishEvent( status , json , myData) client.publishEvent( status , yaml , myData) If you want to lookup which encoder is set for a specific message format use the getMessageEncoderModule(msgFormt) . If an event is sent/received in an unknown format or if a client does not recognize the format, the client library will raise wiotp.sdk.MissingMessageEncoderException or wiotp.sdk.MissingMessageDecoderException .","title":"Custom Message Formats"},{"location":"custommsg/#custom-message-formats","text":"By default, the client library support encoding and decoding events and commands as json messages. To add support for your own custom message formats you can create and register implementations of wiotp.sdk.MessageCodec . MessageCodecs work for both commands and events. To Implement a MessageCodec you must support two static class methods:","title":"Custom Message Formats"},{"location":"custommsg/#encoding","text":"The job of the encode(data, timestamp) method is to take data (any python object) and optionally a timestamp (a datetime.datetime object) and return a String representation of the message ready to be sent over MQTT.","title":"Encoding"},{"location":"custommsg/#decoding","text":"The job of decode(message) is to decode an incoming MQTT message and return an instance of ibmiotf.Message","title":"Decoding"},{"location":"custommsg/#sample-code","text":"import yaml import wiotp.sdk.device import wiotp.sdk.Message import wiotp.sdk.MessageCodec class YamlCodec(ibmiotf.MessageCodec): @staticmethod def encode(data=None, timestamp=None): return yaml.dumps(data) @staticmethod def decode(message): try: data = yaml.loads(message.payload.decode( utf-8 )) except ValueError as e: raise InvalidEventException( Unable to parse YAML. payload=\\ %s\\ error=%s % (message.payload, str(e))) timestamp = datetime.now(pytz.timezone('UTC')) return wiotp.sdk.Message(data, timestamp) myConfig = ibmiotf.device.ParseConfigFile( device.yaml ) client = ibmiotf.device.Client(config=myConfig, logHandlers=None) client.setMessageCodec( yaml , YamlCodec) myData = { 'hello' : 'world', 'x' : 100} # Publish the same event, in both json and yaml formats: client.publishEvent( status , json , myData) client.publishEvent( status , yaml , myData) If you want to lookup which encoder is set for a specific message format use the getMessageEncoderModule(msgFormt) . If an event is sent/received in an unknown format or if a client does not recognize the format, the client library will raise wiotp.sdk.MissingMessageEncoderException or wiotp.sdk.MissingMessageDecoderException .","title":"Sample Code"},{"location":"exceptions/","text":"Exceptions \uf0c1 Exception classes in the SDK are common across the three packages (application, device, gateway). Below is a summary of the custom exception classes that are used in this SDK. All classes extend the base Exception class, in the majority of cases you should be able to develop code without needing to worry about these classes, however their presence allows for more sophisticated error handling in more complex programs. ConnectionException \uf0c1 wiotp.sdk.ConnectionException is a generic Connection exception. More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes UnsupportedAuthenticationMethod \uf0c1 wiotp.sdk.UnsupportedAuthenticationMethod is a specific type of wiotp.sdk.ConnectionException , thrown when the authentication method specified is not supported. More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes ConfigurationException \uf0c1 wiotp.sdk.ConfigurationException is thrown when the configuration passed into an application, device, or gateway client is missing required properties, or has one or more invalid values defined. More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes InvalidEventException \uf0c1 wiotp.sdk.InvalidEventException is thrown when an Event object can not be constructed by a MessageCodec . More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes MissingMessageDecoderException \uf0c1 wiotp.sdk.MissingMessageDecoderException is thrown when there is no message decoder defined for the message format being processed. The specific format that cuased the problem can be found from the format property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes MissingMessageEncoderException \uf0c1 wiotp.sdk.MissingMessageEncoderException is thrown when there is no message encoder defined for the message format being processed. The specific format that cuased the problem can be found from the format property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes ApiException \uf0c1 wiotp.sdk.ApiException is thrown when any API call unexpectedly fails. The thrown exception has a number of properties available to aid in debug: response Full details of the underlying API call that failed. This will be an instance of requests.Response . body The reponse body, if a reponse body was returned. Otherwise None . message The specific error message (in English) returned by IBM Watson IoT Platform. e.g. CUDRS0007E: The request was not valid. Review the constraint violations provided. exception The Exception code and properties for the error message, allowing clients to support error translation. id The exception ID of the error (if available), e.g. CUDRS0007E violations If the error is due to a malformed request, this will contain the list of reasons why the request was rejected. Raised By: Applications: Yes Devices: No Gateways: No","title":"Exceptions"},{"location":"exceptions/#exceptions","text":"Exception classes in the SDK are common across the three packages (application, device, gateway). Below is a summary of the custom exception classes that are used in this SDK. All classes extend the base Exception class, in the majority of cases you should be able to develop code without needing to worry about these classes, however their presence allows for more sophisticated error handling in more complex programs.","title":"Exceptions"},{"location":"exceptions/#connectionexception","text":"wiotp.sdk.ConnectionException is a generic Connection exception. More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes","title":"ConnectionException"},{"location":"exceptions/#unsupportedauthenticationmethod","text":"wiotp.sdk.UnsupportedAuthenticationMethod is a specific type of wiotp.sdk.ConnectionException , thrown when the authentication method specified is not supported. More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes","title":"UnsupportedAuthenticationMethod"},{"location":"exceptions/#configurationexception","text":"wiotp.sdk.ConfigurationException is thrown when the configuration passed into an application, device, or gateway client is missing required properties, or has one or more invalid values defined. More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes","title":"ConfigurationException"},{"location":"exceptions/#invalideventexception","text":"wiotp.sdk.InvalidEventException is thrown when an Event object can not be constructed by a MessageCodec . More details about the exception are available in the reason property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes","title":"InvalidEventException"},{"location":"exceptions/#missingmessagedecoderexception","text":"wiotp.sdk.MissingMessageDecoderException is thrown when there is no message decoder defined for the message format being processed. The specific format that cuased the problem can be found from the format property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes","title":"MissingMessageDecoderException"},{"location":"exceptions/#missingmessageencoderexception","text":"wiotp.sdk.MissingMessageEncoderException is thrown when there is no message encoder defined for the message format being processed. The specific format that cuased the problem can be found from the format property of the thrown exception. Raised By: Applications: Yes Devices: Yes Gateways: Yes","title":"MissingMessageEncoderException"},{"location":"exceptions/#apiexception","text":"wiotp.sdk.ApiException is thrown when any API call unexpectedly fails. The thrown exception has a number of properties available to aid in debug: response Full details of the underlying API call that failed. This will be an instance of requests.Response . body The reponse body, if a reponse body was returned. Otherwise None . message The specific error message (in English) returned by IBM Watson IoT Platform. e.g. CUDRS0007E: The request was not valid. Review the constraint violations provided. exception The Exception code and properties for the error message, allowing clients to support error translation. id The exception ID of the error (if available), e.g. CUDRS0007E violations If the error is due to a malformed request, this will contain the list of reasons why the request was rejected. Raised By: Applications: Yes Devices: No Gateways: No","title":"ApiException"},{"location":"application/","text":"Application SDK Overview \uf0c1 Sorry, this documentation is still a work in progress.","title":"Overview"},{"location":"application/#application-sdk-overview","text":"Sorry, this documentation is still a work in progress.","title":"Application SDK Overview"},{"location":"application/config/","text":"Application Configuration \uf0c1 Sorry, this documentation is still a work in progress.","title":"Configuration"},{"location":"application/config/#application-configuration","text":"Sorry, this documentation is still a work in progress.","title":"Application Configuration"},{"location":"device/","text":"Device SDK Overview \uf0c1 The wiotp.sdk.device package contains the following: Two client implementations: wiotp.sdk.device.DeviceClient wiotp.sdk.device.ManagedDeviceClient Support classes for working with the data model: wiotp.sdk.device.Command wiotp.sdk.device.DeviceInfo wiotp.sdk.device.DeviceFirmware Support methods for handling device configuration: wiotp.sdk.device.parseConfigFile wiotp.sdk.device.parseEnvVars Configuration \uf0c1 Device configuration is passed to the client via the config parameter when you create the client instance. See the configure devices section for full details of all available options, and the built-in support for YAML file and environment variable sourced configuration. myConfig = { identity : { orgId : org1id , typeId : raspberry-pi-3 deviceId : 00ef08ac05 }. auth { token : Ab$76s)asj8_s5 } } client = wiotp.sdk.device.Client(config=myConfig) Connectivity \uf0c1 connect() disconnect() methods are used to manage the MQTT connection to IBM Watson IoT Platform that allows the device to handle commands and publish events. Publishing Events \uf0c1 Events are the mechanism by which devices publish data to the Watson IoT Platform. The device controls the content of the event and assigns a name for each event that it sends. When an event is received by Watson IoT Platform, the credentials of the received event identify the sending device, which means that a device cannot impersonate another device. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. publishEvent() takes up to 5 arguments: event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) on_publish A function that will be called when receipt of the publication is confirmed. Callback and QoS The use of the optional on_publish function has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform Handling Commands \uf0c1 When the device client connects, it automatically subscribes to any command that is specified for this device. To process specific commands, you need to register a command callback method. def myCommandCallback(cmd): print( Command received: %s % cmd.data) client.commandCallback = myCommandCallback The messages are returned as an instance of the Command class with the following attributes: command : Identifies the command format : Format that the command was encoded in, for example json data : Data for the payload converted to a Python dict by an impleentation of MessageCodec timestamp : Date and time that the event was recieved (as datetime.datetime object) If a command is recieved in an unknown format or if a device does not recognize the format, the device library raises wiotp.sdk.MissingMessageDecoderException . Sample Code \uf0c1 import wiotp.sdk.device def myCommandCallback(cmd): print( Command received: %s % cmd.data) # Configure myConfig = wiotp.sdk.device.parseConfigFile( device.yaml ) client = wiotp.sdk.device.Client(config=myConfig, logHandlers=None) client.setKeepAliveInterval(60) client.commandCallback = myCommandCallback # Connect print( Connecting using keepalive interval of %s seconds % (client.getKeepAliveInterval()) ) client.connect() # Send Data myData={'name' : 'foo', 'cpu' : 60, 'mem' : 50} client.publishEvent(event= status , msgFormat= json , data=myData, qos=0, on_publish=None) # Disconnect client.disconnect()","title":"Overview"},{"location":"device/#device-sdk-overview","text":"The wiotp.sdk.device package contains the following: Two client implementations: wiotp.sdk.device.DeviceClient wiotp.sdk.device.ManagedDeviceClient Support classes for working with the data model: wiotp.sdk.device.Command wiotp.sdk.device.DeviceInfo wiotp.sdk.device.DeviceFirmware Support methods for handling device configuration: wiotp.sdk.device.parseConfigFile wiotp.sdk.device.parseEnvVars","title":"Device SDK Overview"},{"location":"device/#configuration","text":"Device configuration is passed to the client via the config parameter when you create the client instance. See the configure devices section for full details of all available options, and the built-in support for YAML file and environment variable sourced configuration. myConfig = { identity : { orgId : org1id , typeId : raspberry-pi-3 deviceId : 00ef08ac05 }. auth { token : Ab$76s)asj8_s5 } } client = wiotp.sdk.device.Client(config=myConfig)","title":"Configuration"},{"location":"device/#connectivity","text":"connect() disconnect() methods are used to manage the MQTT connection to IBM Watson IoT Platform that allows the device to handle commands and publish events.","title":"Connectivity"},{"location":"device/#publishing-events","text":"Events are the mechanism by which devices publish data to the Watson IoT Platform. The device controls the content of the event and assigns a name for each event that it sends. When an event is received by Watson IoT Platform, the credentials of the received event identify the sending device, which means that a device cannot impersonate another device. Events can be published with any of the three quality of service (QoS) levels that are defined by the MQTT protocol. By default, events are published with a QoS level of 0. publishEvent() takes up to 5 arguments: event Name of this event msgFormat Format of the data for this event data Data for this event qos MQTT quality of service level to use ( 0 , 1 , or 2 ) on_publish A function that will be called when receipt of the publication is confirmed. Callback and QoS The use of the optional on_publish function has different implications depending on the level of qos used to publish the event: qos 0: the client has asynchronously begun to send the event qos 1 and 2: the client has confirmation of delivery from the platform","title":"Publishing Events"},{"location":"device/#handling-commands","text":"When the device client connects, it automatically subscribes to any command that is specified for this device. To process specific commands, you need to register a command callback method. def myCommandCallback(cmd): print( Command received: %s % cmd.data) client.commandCallback = myCommandCallback The messages are returned as an instance of the Command class with the following attributes: command : Identifies the command format : Format that the command was encoded in, for example json data : Data for the payload converted to a Python dict by an impleentation of MessageCodec timestamp : Date and time that the event was recieved (as datetime.datetime object) If a command is recieved in an unknown format or if a device does not recognize the format, the device library raises wiotp.sdk.MissingMessageDecoderException .","title":"Handling Commands"},{"location":"device/#sample-code","text":"import wiotp.sdk.device def myCommandCallback(cmd): print( Command received: %s % cmd.data) # Configure myConfig = wiotp.sdk.device.parseConfigFile( device.yaml ) client = wiotp.sdk.device.Client(config=myConfig, logHandlers=None) client.setKeepAliveInterval(60) client.commandCallback = myCommandCallback # Connect print( Connecting using keepalive interval of %s seconds % (client.getKeepAliveInterval()) ) client.connect() # Send Data myData={'name' : 'foo', 'cpu' : 60, 'mem' : 50} client.publishEvent(event= status , msgFormat= json , data=myData, qos=0, on_publish=None) # Disconnect client.disconnect()","title":"Sample Code"},{"location":"device/config/","text":"Device Configuration \uf0c1 Device configuration can be broken down into required and optional configuration: Required Configuration \uf0c1 identity.orgId Your organization ID. identity.typeId The type of the device. Think of the device type is analagous to a model number. identity.deviceId A unique ID to identify a device. Think of the device id as analagous to a serial number. auth.token An authentication token to securely connect your device to Watson IoT Platform. Optional Configuration \uf0c1 options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to auto-negotiation. options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when constructing an instance of wiotp.sdk.device.DeviceClient expects to be passed a dictionary containing this configuration: myConfig = { identity : { orgId : org1id , typeId : raspberry-pi-3 deviceId : 00ef08ac05 }. auth { token : Ab$76s)asj8_s5 }, options : { domain : internetofthings.ibmcloud.com , logLevel : error|warning|info|debug , mqtt : { port : 8883, transport : tcp|websockets , cleanStart : True|False, sessionExpiry : 3600, keepAlive : 60, caFile : /path/to/certificateAuthorityFile.pem } } } client = wiotp.sdk.device.DeviceClient(config=myConfig, logHandlers=None) In most cases you will not manually build the config dictionary. Two helper methods are provided to make configuration simple: YAML File Support \uf0c1 wiotp.sdk.device.parseConfigFile() allows one to easily pass in device configuration from environment variables. import wiotp.device.sdk myConfig = wiotp.sdk.device.parseConfigFile( device.yaml ) client = ibmiotf.device.Client(config=myConfig, logHandlers=None) Minimal Required Configuration File \uf0c1 identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 Complete Configuration File \uf0c1 This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem Environment Variable Support \uf0c1 wiotp.sdk.device.parseEnvVars() allows one to easily pass in device configuration from environment variables. import wiotp.sdk.device myConfig = wiotp.sdk.device.parseEnvVars() client = wiopt.sdk.device.Client(config=myConfig, logHandlers=None) Minimal Required Environment Variables \uf0c1 WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN Optional Additional Environment Variables \uf0c1 WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Configuration"},{"location":"device/config/#device-configuration","text":"Device configuration can be broken down into required and optional configuration:","title":"Device Configuration"},{"location":"device/config/#required-configuration","text":"identity.orgId Your organization ID. identity.typeId The type of the device. Think of the device type is analagous to a model number. identity.deviceId A unique ID to identify a device. Think of the device id as analagous to a serial number. auth.token An authentication token to securely connect your device to Watson IoT Platform.","title":"Required Configuration"},{"location":"device/config/#optional-configuration","text":"options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to auto-negotiation. options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when constructing an instance of wiotp.sdk.device.DeviceClient expects to be passed a dictionary containing this configuration: myConfig = { identity : { orgId : org1id , typeId : raspberry-pi-3 deviceId : 00ef08ac05 }. auth { token : Ab$76s)asj8_s5 }, options : { domain : internetofthings.ibmcloud.com , logLevel : error|warning|info|debug , mqtt : { port : 8883, transport : tcp|websockets , cleanStart : True|False, sessionExpiry : 3600, keepAlive : 60, caFile : /path/to/certificateAuthorityFile.pem } } } client = wiotp.sdk.device.DeviceClient(config=myConfig, logHandlers=None) In most cases you will not manually build the config dictionary. Two helper methods are provided to make configuration simple:","title":"Optional Configuration"},{"location":"device/config/#yaml-file-support","text":"wiotp.sdk.device.parseConfigFile() allows one to easily pass in device configuration from environment variables. import wiotp.device.sdk myConfig = wiotp.sdk.device.parseConfigFile( device.yaml ) client = ibmiotf.device.Client(config=myConfig, logHandlers=None)","title":"YAML File Support"},{"location":"device/config/#minimal-required-configuration-file","text":"identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5","title":"Minimal Required Configuration File"},{"location":"device/config/#complete-configuration-file","text":"This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem","title":"Complete Configuration File"},{"location":"device/config/#environment-variable-support","text":"wiotp.sdk.device.parseEnvVars() allows one to easily pass in device configuration from environment variables. import wiotp.sdk.device myConfig = wiotp.sdk.device.parseEnvVars() client = wiopt.sdk.device.Client(config=myConfig, logHandlers=None)","title":"Environment Variable Support"},{"location":"device/config/#minimal-required-environment-variables","text":"WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN","title":"Minimal Required Environment Variables"},{"location":"device/config/#optional-additional-environment-variables","text":"WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Optional Additional Environment Variables"},{"location":"device/managed/","text":"Managed Device \uf0c1 Sorry, this documentation is still a work in progress.","title":"Managed Devices"},{"location":"device/managed/#managed-device","text":"Sorry, this documentation is still a work in progress.","title":"Managed Device"},{"location":"gateway/","text":"Gateway SDK Overview \uf0c1 Sorry, this documentation is still a work in progress.","title":"Gateway SDK Overview"},{"location":"gateway/#gateway-sdk-overview","text":"Sorry, this documentation is still a work in progress.","title":"Gateway SDK Overview"},{"location":"gateway/config/","text":"Gateway Configuration \uf0c1 Gateway configuration can be broken down into required and optional configuration: Required Configuration \uf0c1 identity.orgId Your organization ID. identity.typeId The type of the device. Think of the device type is analagous to a model number. identity.deviceId A unique ID to identify a device. Think of the device id as analagous to a serial number. auth.token An authentication token to securely connect your device to Watson IoT Platform. Optional Configuration \uf0c1 options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to auto-negotiation. options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when constructing an instance of wiotp.sdk.gateway.GatewayClient expects to be passed a dictionary containing this configuration: myConfig = { identity : { orgId : org1id , typeId : raspberry-pi-3 deviceId : 00ef08ac05 }. auth { token : Ab$76s)asj8_s5 }, options : { domain : internetofthings.ibmcloud.com , logLevel : error|warning|info|debug , mqtt : { port : 8883, transport : tcp|websockets , cleanStart : True|False, sessionExpiry : 3600, keepAlive : 60, caFile : /path/to/certificateAuthorityFile.pem } } } client = wiotp.sdk.gateway.GatewayClient(config=myConfig, logHandlers=None) In most cases you will not manually build the config dictionary. Two helper methods are provided to make configuration simple: YAML File Support \uf0c1 wiotp.sdk.gateway.parseConfigFile() allows one to easily pass in gateway configuration from environment variables. import wiotp.gateway.sdk myConfig = wiotp.sdk.device.parseConfigFile( gateway.yaml ) client = ibmiotf.gateway.Client(config=myConfig, logHandlers=None) Minimal Required Configuration File \uf0c1 identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 Complete Configuration File \uf0c1 This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem Environment Variable Support \uf0c1 wiotp.sdk.gateway.parseEnvVars() allows one to easily pass in gateway configuration from environment variables. import wiotp.sdk.gateway myConfig = wiotp.sdk.gateway.parseEnvVars() client = wiopt.sdk.gateway.Client(config=myConfig, logHandlers=None) Minimal Required Environment Variables \uf0c1 WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN Optional Additional Environment Variables \uf0c1 WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"GatewayConfiguration"},{"location":"gateway/config/#gateway-configuration","text":"Gateway configuration can be broken down into required and optional configuration:","title":"Gateway Configuration"},{"location":"gateway/config/#required-configuration","text":"identity.orgId Your organization ID. identity.typeId The type of the device. Think of the device type is analagous to a model number. identity.deviceId A unique ID to identify a device. Think of the device id as analagous to a serial number. auth.token An authentication token to securely connect your device to Watson IoT Platform.","title":"Required Configuration"},{"location":"gateway/config/#optional-configuration","text":"options.domain A boolean value indicating which Watson IoT Platform domain to connect to (e.g. if you have a dedicated platform instance). Defaults to internetofthings.ibmcloud.com options.logLevel Controls the level of logging in the client, can be set to error , warning , info , or debug . Defaults to info . options.mqtt.port A integer value defining the MQTT port. Defaults to auto-negotiation. options.mqtt.transport The transport to use for MQTT connectivity - tcp or websockets . options.mqtt.cleanStart A boolean value indicating whether to discard any previous state when reconnecting to the service. Defaults to False . options.mqtt.sessionExpiry When cleanStart is disabled, defines the maximum age of the previous session (in seconds). Defaults to False . options.mqtt.keepAlive Control the frequency of MQTT keep alive packets (in seconds). Details to 60 . options.mqtt.caFile A String value indicating the path to a CA file (in pem format) to use in verifying the server certificate. Defaults to messaging.pem inside this module. The config parameter when constructing an instance of wiotp.sdk.gateway.GatewayClient expects to be passed a dictionary containing this configuration: myConfig = { identity : { orgId : org1id , typeId : raspberry-pi-3 deviceId : 00ef08ac05 }. auth { token : Ab$76s)asj8_s5 }, options : { domain : internetofthings.ibmcloud.com , logLevel : error|warning|info|debug , mqtt : { port : 8883, transport : tcp|websockets , cleanStart : True|False, sessionExpiry : 3600, keepAlive : 60, caFile : /path/to/certificateAuthorityFile.pem } } } client = wiotp.sdk.gateway.GatewayClient(config=myConfig, logHandlers=None) In most cases you will not manually build the config dictionary. Two helper methods are provided to make configuration simple:","title":"Optional Configuration"},{"location":"gateway/config/#yaml-file-support","text":"wiotp.sdk.gateway.parseConfigFile() allows one to easily pass in gateway configuration from environment variables. import wiotp.gateway.sdk myConfig = wiotp.sdk.device.parseConfigFile( gateway.yaml ) client = ibmiotf.gateway.Client(config=myConfig, logHandlers=None)","title":"YAML File Support"},{"location":"gateway/config/#minimal-required-configuration-file","text":"identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5","title":"Minimal Required Configuration File"},{"location":"gateway/config/#complete-configuration-file","text":"This file defines all optional configuration parameters. identity: orgId: org1id typeId: raspberry-pi deviceId: 00ef08ac05 auth: token: Ab$76s)asj8_s5 options: domain: internetofthings.ibmcloud.com logLevel: debug mqtt: port: 8883 transport: tcp cleanStart: true sessionExpiry: 7200 keepAlive: 120 caFile: /path/to/certificateAuthorityFile.pem","title":"Complete Configuration File"},{"location":"gateway/config/#environment-variable-support","text":"wiotp.sdk.gateway.parseEnvVars() allows one to easily pass in gateway configuration from environment variables. import wiotp.sdk.gateway myConfig = wiotp.sdk.gateway.parseEnvVars() client = wiopt.sdk.gateway.Client(config=myConfig, logHandlers=None)","title":"Environment Variable Support"},{"location":"gateway/config/#minimal-required-environment-variables","text":"WIOTP_IDENTITY_ORGID WIOTP_IDENTITY_TYPEID WIOTP_IDENTITY_DEVICEID WIOTP_AUTH_TOKEN","title":"Minimal Required Environment Variables"},{"location":"gateway/config/#optional-additional-environment-variables","text":"WIOTP_OPTIONS_DOMAIN WIOTP_OPTIONS_LOGLEVEL WIOTP_OPTIONS_MQTT_PORT WIOTP_OPTIONS_MQTT_TRANSPORT WIOTP_OPTIONS_MQTT_CAFILE WIOTP_OPTIONS_MQTT_CLEANSTART WIOTP_OPTIONS_MQTT_SESSIONEXPIRY WIOTP_OPTIONS_MQTT_KEEPALIVE","title":"Optional Additional Environment Variables"},{"location":"gateway/managed/","text":"Managed Gateway \uf0c1 Sorry, this documentation is still a work in progress.","title":"Managed Gateways"},{"location":"gateway/managed/#managed-gateway","text":"Sorry, this documentation is still a work in progress.","title":"Managed Gateway"}]}